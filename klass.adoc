:imagesdir: photo

= Отчет по классам

=== В данной работе стояла задача разобраться с объектно-ориентированным программированием, понятием класса и объекта.

Объектно-ориентированное программирование (ООП, Object-Oriented
Programming) - совокупность принципов, технологий, а также
инструментальных средств для создания программных систем на основе
архитектуры взаимодействия объектов.

Класс представляет собой абстракцию совокупности реальных объектов, которые имеют общий набор свойств и
обладают одинаковым поведением. 

Фактически он описывает устройство объекта, являясь своего рода чертежом.  

Объект в контексте ООП рассматривается как экземпляр соответствующего класса. (например, классом может являться
человек, а экземпляр класса человек - Усирков Александр).

Объекты, которые не имеют идентичных свойств или не
обладают одинаковым поведением, по определению, не могут быть отнесены к одному классу. (например, лимон, у него
нет цвета глаз)

В работе до этого, я познакомился с настройкой и работой АЦП, с помощью которого получали данные по температуре и напряжению.

В этой работе стояла задача оформить классы, т.е визуально сделать задачу "под пользователя"

Итак, _первое что нужно для начала работы с классами - оформить его структуру в специальной программе UML._

*Язык UML представляет собой общецелевой язык визуального моделирования, который
разработан для спецификации, визуализации, проектирования и документирования
компонентов программного обеспечения, бизнес-процессов и других систем.*

Сделать класс отдельной классовой диаграммой, с набором определенных атрибутов и операций, которые подходят лишь под отдельно заданный класс.

=== Класс АЦП

Рассмотрим пример классовой диаграммы для класса АЦП: 


image::ACP.png[]

В нем мы видим 10 операций, которые присущи конкретно лишь классу АЦП, и пояснения для них в окне правее.

По операциям:

image::щт.png[]

Надпись public - публичный, открыт для просмотра, далее идет название операции ([underline]##обязательно такое же, какое дали в UML!##)

И сама операция, в виде кода, в данном случае на примере операции включения - Adc::CR2::ADON::Enable::Set(); 

image::nd5.png[]

И по такому же принципу мы создаем дальше операции, которые сами решили, что нам необходимы

_(Сергей Владимирович, я опущу описание операций в одно действие, с вашего разрешения <3)_

Операция Config Resolution - операция с несколькими кейсами, у каждого кейса свое значение разрядности, и пользователю лишь поменять следует кейс, при изменении разряда.

image::case.png[]

Операция ConfigChannel - настройка каналов на измерений:
Adc::SQR1::L::Conversions2::Set(); - показывает количетсво измерений
     assert(NumChannel < 19);
     Adc::SQR3::SQ1::Set(NumChannel); // kanal 
     assert(NumChannel1 < 19);
     Adc::SQR3::SQ2::Set(NumChannel1); 

Показывает, что будут два номера измерений, а assert - задает значение, которое не должно превышать введенное значение, т.к каналов 18, то не должно превышать 19.

Операция ScanConfig - операция для настройки и включения сканирования, ничего сложного и необычного нет, всё из библии.

И вот теперь, после того, как прописали архитектуру в UML, расписали её (а самое главное поняли что она делает), для красоты и удобства добавляем в дерево проекта файл hpp, в котором прописан весь класс.

image::all.png[]

Далее, по такому же принципу надо было сделать класс для температуры и напряжения.

=== Класс Температуры

image::t1.png[]

Судь данного описания архитектуры: у этого класса есть 3 атрибута, и 3 операции.

Атрибуты у нас приватные - коэффициент наклона (К), коэффициент смещения (B), value - рассчитанное значение температуры.

И три операции: непосредственно операция расчета с помощью коэффициентов и формулы : value = data1* K1 + B1; где data1 - данные, получаемые с АЦП.

GetValue получение значения, рассчитанного методом (операцией) Calculate() 

И третье - инициализация коэффицентов K1, B1 новыми значениями с помощью конструктора Tempearute, нужно это если будут заменяться коэффициенты, и вечно в формуле их не менять.


Сам код для класса температуры выглядит следующим образом - 

    class Temperature
    {
    private:
      float B1 = (25.0F-0.76F/0.0025F); 
      float K1 = ((3.3F/4096.0F)/0.0025F); 
     float value = 0.0F ;
    public:
     Temperature ()
     {
     };
     Temperature (float K, float B): K1(K), B1(B)
    {
    }
      ;
     void Calculation (std::uint32_t data1)
     {
      value = data1* K1 + B1;
    }
     float GetValue() 
    {
    return value ;
     }
    };
    

=== Класс Напряжения

Код для класса напряжения идентичен коду для температуры, те же переменные (но значение разное, конечно), формула та же, операции те же самые, что были выше, в классе температуры.

Атрибуты у нас приватные - коэффициент наклона (К), коэффициент смещения (B), value - рассчитанное значение температуры.

И три операции: непосредственно операция расчета с помощью коэффициентов и формулы : value = data1* K2 + B2; где data2 - данные, получаемые с АЦП.

GetValue получение значения, рассчитанного методом (операцией) Calculate() 

И третье - инициализация коэффицентов K2, B2 новыми значениями с помощью конструктора Tempearute, нужно это если будут заменяться коэффициенты, и вечно в формуле их не менять.


image::v_1.png[]

    class Voltage
    {
    private:
     float B2 = 0.0F; 
     float K2 = (3.3F/4096.0F); 
     float value = 0.0F ;
    public:
     Voltage ()
     {
     };
     Voltage (float K, float B): K2(K), B2(B)
     {
     }
      ;
     void CalculationV (std::uint32_t data2)
     {
       value = data2 * K2 + B2;
     }
     float GetValueV() 
     {
      return value ;
     }
    };
    

=== Итог по этой работе:

В итоге рабочий main выглядит следующим образом:

image::main.png[]

=== Окно вывода результатов измерений:

image::izmerenie.png[]

=== Вывод:

Данный способ описания/написания класса является, насколько я понимаю, композицией.

Композиция (агрегирование, включение) –
простейший механизм для создания нового
класса путем объединения нескольких объектов
существующих классов в единое целое

Другая задача состоит в том, чтобы написать код для класса наследования:

== Наследование

Важнейший механизм ООП, позволяющий
описать новый класс на основе уже
существующего
● При наследовании свойства и функциональность
родительского класса наследуются новым
классом

Происходит в стиле того, что два класса : напряжение и температуры идентичны, и у них можно провести наследование параметров.

image::tav.png[]

На данный момент выглядит так, что у них все обобщенное, и можно сделать класс наследования.

image::1.png[]

Есть так же скрытые, приватные атрибуты, и операции, но уже операции с массивом, состоящим из двух элементов - температуры и напряжения, для этого ещё используется указатель типа char*. (Как я понял, прочитав ещё лекцию 2, по указателям :D )

Ну и так же операции, присущие данному классу IVariable, делается наследование для упрощения кода для пользователя, который не будет лезть в структурную составляющую.

=== Класс IVariable



    class IVariable
    {
    private:
      const float B1= 0.0F;
      const float K1 = 0.0F;
      float Value = 0.0F;  

      const char* Name = "Variable       " ; 
    public:
  IVariable(float B, float K, const char* str): B1(B), K1(K), Name(str) 
  {
  };
   
  float GetValue()
  {
    return Value ;
  }
  
  virtual void Calculate(uint32_t code)
  {
     Value = code * B1 + K1 ;
  }
  
  const char* GetName()
  {
     return Name;
  }
  
    };


Здесь выглядит все так же, как в тех классах : напряжении и температуре, лишь различие что это всё объединено, а значит, что нужно писать одни операции
(я просто любитель писать названия операций для разных классов разными, а тут надо все в одном названии делать)


Получается, что есть главный класс IVariable, а два других класса наследуют его значения, его операции и так далее.

Как итог, выходит вот такое:

image::result.png[]

Ну и в итоге всего сделанного небольшие отсылки:

image::nd1.png[]

image::nd5.png[]

image::nd2.png[]

image::cool.png[]

*Надеюсь, мои мемы подойдут к вашим лекциям в следующие года.. *