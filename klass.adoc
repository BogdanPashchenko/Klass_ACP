:imagesdir: photo

Стояла задача сделать класс для прошлой лабораторной работы, где проводились измерения напряжения и температуры с помощью АЦП.

Первое, что нужно сделать - создать архитектуру отдельно взятого каждого класса (в данной лабораторной их 3).

Архитектура класса АЦП выглядит следующим образом:

image::ACP.png[]

И, после того, как прописали архитектуру в программе UML, следует прописать её либо в рабочем коде (файл main), либо же, для большего удобства и красоты, в отдельно взятом hpp- файле, что и было сделано (так же как и для температуры и напряжения).

image::all.png[]

Сам код для класса АЦП:

    enum class Resolution 
    {
  Bits12,
  Bits10,
  Bits8,
  Bits6,
    };
    template <class Adc>
    class ADC
    {
    public: 
  static void On()
     { 
    Adc::CR2::ADON::Enable::Set(); 
     }
    static void Off()
    {
    Adc::CR2::ADON::Disable::Set();
    }
     static void Start()
    {
      Adc::CR2::SWSTART::On::Set(); 
    }
    static bool IsReady()
    {
      return  Adc::SR::EOC::ConversionComplete::IsSet(); //preobr zakoncheno
    }
    static uint32_t Get()
     {
      return Adc::DR::Get() ;
     }
     static void Config(Resolution resolution)
     {
       switch (resolution)
       {
     case Resolution::Bits12:
       Adc::CR1::RES::Bits12::Set();
       break;
     case Resolution::Bits10:
       Adc::CR1::RES::Bits10::Set();
       break;
     case Resolution::Bits8:
       Adc::CR1::RES::Bits8::Set();
       break;
     case Resolution::Bits6:
       Adc::CR1::RES::Bits6::Set();
       break;
       default:
       Adc::CR1::RES::Bits12::Set();
       break;
     }
    }
     static void ConfigChannel (std::uint32_t NumChannel,std::uint32_t NumChannel1) //izmerenia
     {
     ScanConfig() ;
     Adc::SQR1::L::Conversions2::Set();
     assert(NumChannel < 19);
     Adc::SQR3::SQ1::Set(NumChannel); // kanal 
     assert(NumChannel1 < 19);
     Adc::SQR3::SQ2::Set(NumChannel1); // kanal 
   }
  
     static void ScanConfig()
     {
    Adc::CR1::SCAN::Enable::Set();
    Adc::CR2::CONT::SingleConversion::Set(); 
    Adc::CR2::EOCS::SingleConversion::Set(); 
  }
    } ;
    

Здесь расписано по классам, которые были представлены в архитектуре.

Далее точно так же надо было сделать с температурой и напряжением:

image::tav.png[]

Код для класса температуры - 

    class Temperature
    {
    private:
      float B1 = (25.0F-0.76F/0.0025F); 
      float K1 = ((3.3F/4096.0F)/0.0025F); 
     float value = 0.0F ;
    public:
     Temperature ()
     {
     };
     Temperature (float K, float B): K1(K), B1(B)
    {
    }
      ;
     void Calculation (std::uint32_t data1)
     {
      value = data1* K1 + B1;
    }
     float GetValue() 
    {
    return value ;
     }
    };
    
Код для класса напряжения - 

    class Voltage
    {
    private:
     float B2 = 0.0F; 
     float K2 = (3.3F/4096.0F); 
     float value = 0.0F ;
    public:
     Voltage ()
     {
     };
     Voltage (float K, float B): K2(K), B2(B)
     {
     }
      ;
     void CalculationV (std::uint32_t data2)
     {
       value = data2 * K2 + B2;
     }
     float GetValueV() 
     {
      return value ;
     }
    };
    
В итоге, вместе с этими классами рабочий main выглядит следующим образом :

image::main.png[]

Окно вывода результатов измерений:

image::izmerenie.png[]


Далее следует объединить два класса (температуры и напряжения) в один:

image::t.png[]

image::v.png[]

image::ivar.png[]

main получается следующим образом:

image::main2.png[]

Но дальше у меня вылезает ошибка, и я не могу понять в связи с чем:

image::help.png[]

image::heelp2.png[]